import logger from '@wdio/logger';
import NetworkHandler from './handler/network.js';
import { DEFAULT_TRACING_CATEGORIES } from './constants.js';
import { sumByKey } from './utils.js';
const log = logger('@wdio/devtools-service:CommandHandler');
export default class CommandHandler {
    _session;
    _page;
    _isTracing = false;
    _networkHandler;
    _traceEvents;
    constructor(_session, _page, browser) {
        this._session = _session;
        this._page = _page;
        this._networkHandler = new NetworkHandler(_session);
        /**
         * register browser commands
         */
        const commands = Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(fnName => fnName !== 'constructor' && !fnName.startsWith('_'));
        commands.forEach(fnName => browser.addCommand(fnName, this[fnName].bind(this)));
    }
    /**
     * The cdp command is a custom command added to the browser scope that allows you
     * to call directly commands to the protocol.
     */
    cdp(domain, command, args = {}) {
        log.info(`Send command "${domain}.${command}" with args: ${JSON.stringify(args)}`);
        return this._session.send(`${domain}.${command}`, args);
    }
    /**
     * Helper method to get the nodeId of an element in the page.
     * NodeIds are similar like WebDriver node ids an identifier for a node.
     * It can be used as a parameter for other Chrome DevTools methods, e.g. DOM.focus.
     */
    async getNodeId(selector) {
        const document = await this._session.send('DOM.getDocument');
        const { nodeId } = await this._session.send('DOM.querySelector', { nodeId: document.root.nodeId, selector });
        return nodeId;
    }
    /**
     * Helper method to get the nodeId of an element in the page.
     * NodeIds are similar like WebDriver node ids an identifier for a node.
     * It can be used as a parameter for other Chrome DevTools methods, e.g. DOM.focus.
     */
    async getNodeIds(selector) {
        const document = await this._session.send('DOM.getDocument');
        const { nodeIds } = await this._session.send('DOM.querySelectorAll', { nodeId: document.root.nodeId, selector });
        return nodeIds;
    }
    /**
     * Start tracing the browser. You can optionally pass in custom tracing categories and the
     * sampling frequency.
     */
    startTracing({ categories = DEFAULT_TRACING_CATEGORIES, path, screenshots = true } = {}) {
        if (this._isTracing) {
            throw new Error('browser is already being traced');
        }
        this._isTracing = true;
        this._traceEvents = undefined;
        return this._page.tracing.start({ categories, path, screenshots });
    }
    /**
     * Stop tracing the browser.
     */
    async endTracing() {
        if (!this._isTracing) {
            throw new Error('No tracing was initiated, call `browser.startTracing()` first');
        }
        try {
            const traceBuffer = await this._page.tracing.stop();
            if (!traceBuffer) {
                throw new Error('No tracebuffer captured');
            }
            this._traceEvents = JSON.parse(traceBuffer.toString('utf8'));
            this._isTracing = false;
        }
        catch (err) {
            throw new Error(`Couldn't parse trace events: ${err.message}`);
        }
        return this._traceEvents;
    }
    /**
     * Returns the tracelogs that was captured within the tracing period.
     * You can use this command to store the trace logs on the file system to analyse the trace
     * via Chrome DevTools interface.
     */
    getTraceLogs() {
        return this._traceEvents;
    }
    /**
     * Returns page weight information of the last page load.
     */
    getPageWeight() {
        const requestTypes = Object.values(this._networkHandler.requestTypes).filter(Boolean);
        const pageWeight = sumByKey(requestTypes, 'size');
        const transferred = sumByKey(requestTypes, 'encoded');
        const requestCount = sumByKey(requestTypes, 'count');
        return { pageWeight, transferred, requestCount, details: this._networkHandler.requestTypes };
    }
}
