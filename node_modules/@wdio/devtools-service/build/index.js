import logger from '@wdio/logger';
import { KnownDevices } from 'puppeteer-core';
import CommandHandler from './commands.js';
import Auditor from './auditor.js';
import PWAGatherer from './gatherer/pwa.js';
import TraceGatherer from './gatherer/trace.js';
import CoverageGatherer from './gatherer/coverage.js';
import DevtoolsGatherer from './gatherer/devtools.js';
import { isBrowserSupported, setUnsupportedCommand, getLighthouseDriver } from './utils.js';
import { NETWORK_STATES, UNSUPPORTED_ERROR_MESSAGE, CLICK_TRANSITION, DEFAULT_THROTTLE_STATE } from './constants.js';
const log = logger('@wdio/devtools-service');
const TRACE_COMMANDS = ['click', 'navigateTo', 'url'];
function isCDPSessionOnMessageObject(data) {
    return (data !== null &&
        typeof data === 'object' &&
        Object.prototype.hasOwnProperty.call(data, 'params') &&
        Object.prototype.hasOwnProperty.call(data, 'method'));
}
export default class DevToolsService {
    _options;
    _isSupported = false;
    _shouldRunPerformanceAudits = false;
    _puppeteer;
    _target;
    _page = null;
    _session;
    _driver;
    _cacheEnabled;
    _cpuThrottling;
    _networkThrottling;
    _formFactor;
    _traceGatherer;
    _devtoolsGatherer;
    _coverageGatherer;
    _pwaGatherer;
    _browser;
    constructor(_options) {
        this._options = _options;
    }
    beforeSession(_, caps) {
        if (!isBrowserSupported(caps)) {
            return log.error(UNSUPPORTED_ERROR_MESSAGE);
        }
        this._isSupported = true;
    }
    before(caps, specs, browser) {
        this._browser = browser;
        this._isSupported = this._isSupported || Boolean(this._browser.puppeteer);
        return this._setupHandler();
    }
    async onReload() {
        if (!this._browser) {
            return;
        }
        return this._setupHandler();
    }
    async beforeCommand(commandName, params) {
        const isCommandNavigation = ['url', 'navigateTo'].some(cmdName => cmdName === commandName);
        if (!this._shouldRunPerformanceAudits || !this._traceGatherer || this._traceGatherer.isTracing || !TRACE_COMMANDS.includes(commandName)) {
            return;
        }
        /**
         * set browser profile
         */
        this._setThrottlingProfile(this._networkThrottling, this._cpuThrottling, this._cacheEnabled);
        const url = isCommandNavigation
            ? params[0]
            : CLICK_TRANSITION;
        return this._traceGatherer.startTracing(url);
    }
    async afterCommand(commandName) {
        if (!this._traceGatherer || !this._traceGatherer.isTracing || !TRACE_COMMANDS.includes(commandName)) {
            return;
        }
        /**
         * update custom commands once tracing finishes
         */
        this._traceGatherer.once('tracingComplete', (traceEvents) => {
            const auditor = new Auditor(traceEvents, this._devtoolsGatherer?.getLogs(), this._formFactor);
            auditor.updateCommands(this._browser);
        });
        this._traceGatherer.once('tracingError', (err) => {
            const auditor = new Auditor();
            auditor.updateCommands(this._browser, /* istanbul ignore next */ () => {
                throw new Error(`Couldn't capture performance due to: ${err.message}`);
            });
        });
        return new Promise((resolve) => {
            log.info(`Wait until tracing for command ${commandName} finishes`);
            /**
             * wait until tracing stops
             */
            this._traceGatherer?.once('tracingFinished', async () => {
                log.info('Disable throttling');
                await this._setThrottlingProfile('online', 0, true);
                log.info('continuing with next WebDriver command');
                resolve();
            });
        });
    }
    async after() {
        if (this._coverageGatherer) {
            await this._coverageGatherer.logCoverage();
        }
    }
    /**
     * set flag to run performance audits for page transitions
     */
    _enablePerformanceAudits({ networkThrottling, cpuThrottling, cacheEnabled, formFactor } = DEFAULT_THROTTLE_STATE) {
        if (!NETWORK_STATES[networkThrottling]) {
            throw new Error(`Network throttling profile "${networkThrottling}" is unknown, choose between ${Object.keys(NETWORK_STATES).join(', ')}`);
        }
        if (typeof cpuThrottling !== 'number') {
            throw new Error(`CPU throttling rate needs to be typeof number but was "${typeof cpuThrottling}"`);
        }
        this._networkThrottling = networkThrottling;
        this._cpuThrottling = cpuThrottling;
        this._cacheEnabled = Boolean(cacheEnabled);
        this._formFactor = formFactor;
        this._shouldRunPerformanceAudits = true;
    }
    /**
     * custom command to disable performance audits
     */
    _disablePerformanceAudits() {
        this._shouldRunPerformanceAudits = false;
    }
    /**
     * set device emulation
     */
    async _emulateDevice(device, inLandscape) {
        if (!this._page) {
            throw new Error('No page has been captured yet');
        }
        if (typeof device === 'string') {
            const deviceName = device + (inLandscape ? ' landscape' : '');
            const deviceCapabilities = KnownDevices[deviceName];
            if (!deviceCapabilities) {
                const deviceNames = Object.values(KnownDevices)
                    .map((device) => device.name)
                    .filter((device) => !device.endsWith('landscape'));
                throw new Error(`Unknown device, available options: ${deviceNames.join(', ')}`);
            }
            return this._page.emulate(deviceCapabilities);
        }
        return this._page.emulate(device);
    }
    /**
     * helper method to set throttling profile
     */
    async _setThrottlingProfile(networkThrottling = DEFAULT_THROTTLE_STATE.networkThrottling, cpuThrottling = DEFAULT_THROTTLE_STATE.cpuThrottling, cacheEnabled = DEFAULT_THROTTLE_STATE.cacheEnabled) {
        if (!this._page || !this._session) {
            throw new Error('No page or session has been captured yet');
        }
        await this._page.setCacheEnabled(Boolean(cacheEnabled));
        await this._session.send('Emulation.setCPUThrottlingRate', { rate: cpuThrottling });
        await this._session.send('Network.emulateNetworkConditions', NETWORK_STATES[networkThrottling]);
    }
    async _checkPWA(auditsToBeRun) {
        const auditor = new Auditor();
        const artifacts = await this._pwaGatherer.gatherData();
        return auditor._auditPWA(artifacts, auditsToBeRun);
    }
    _getCoverageReport() {
        return this._coverageGatherer.getCoverageReport();
    }
    async _setupHandler() {
        if (!this._isSupported || !this._browser) {
            return setUnsupportedCommand(this._browser);
        }
        /**
         * casting is required as types differ between core and definitely typed types
         */
        this._puppeteer = await this._browser.getPuppeteer();
        /* istanbul ignore next */
        if (!this._puppeteer) {
            throw new Error('Could not initiate Puppeteer instance');
        }
        this._target = await this._puppeteer.waitForTarget(
        /* istanbul ignore next */
        (t) => t.type() === 'page' || Boolean(t._getTargetInfo().browserContextId));
        /* istanbul ignore next */
        if (!this._target) {
            throw new Error('No page target found');
        }
        this._page = await this._target.page() || null;
        /* istanbul ignore next */
        if (!this._page) {
            throw new Error('No page found');
        }
        this._session = await this._target.createCDPSession();
        this._driver = await getLighthouseDriver(this._session, this._target);
        new CommandHandler(this._session, this._page, this._browser);
        this._traceGatherer = new TraceGatherer(this._session, this._page, this._driver);
        this._session.on('Page.loadEventFired', this._traceGatherer.onLoadEventFired.bind(this._traceGatherer));
        this._session.on('Page.frameNavigated', this._traceGatherer.onFrameNavigated.bind(this._traceGatherer));
        this._page.on('requestfailed', this._traceGatherer.onFrameLoadFail.bind(this._traceGatherer));
        /**
         * enable domains for client
         */
        await Promise.all(['Page', 'Network', 'Runtime'].map((domain) => Promise.all([
            this._session?.send(`${domain}.enable`)
        ])));
        /**
         * register coverage gatherer if options is set by user
         */
        if (this._options.coverageReporter?.enable) {
            this._coverageGatherer = new CoverageGatherer(this._page, this._options.coverageReporter);
            this._browser.addCommand('getCoverageReport', this._getCoverageReport.bind(this));
            await this._coverageGatherer.init();
        }
        this._devtoolsGatherer = new DevtoolsGatherer();
        this._session.on('*', this._propagateWSEvents.bind(this));
        this._browser.addCommand('enablePerformanceAudits', this._enablePerformanceAudits.bind(this));
        this._browser.addCommand('disablePerformanceAudits', this._disablePerformanceAudits.bind(this));
        this._browser.addCommand('emulateDevice', this._emulateDevice.bind(this));
        this._pwaGatherer = new PWAGatherer(this._session, this._page, this._driver);
        this._browser.addCommand('checkPWA', this._checkPWA.bind(this));
    }
    _propagateWSEvents(data) {
        if (!isCDPSessionOnMessageObject(data)) {
            return;
        }
        this._devtoolsGatherer?.onMessage(data);
        const method = data.method || 'event';
        try {
            // can fail due to "Cannot convert a Symbol value to a string"
            log.debug(`cdp event: ${method} with params ${JSON.stringify(data.params)}`);
        }
        catch {
            // ignore
        }
        if (this._browser) {
            this._browser.emit(method, data.params);
        }
    }
}
export * from './types.js';
